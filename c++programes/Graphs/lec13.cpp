#include<iostream>
#include<vector>
#include<unordered_map>
#include<list>
#include<stack>
using namespace std;

// Count Strongly Connected Components (Kosaraju's Algorithm)

// You are given an unweighted directed graph having 'V' vertices and 'E' edges. Your task is to count the number of strongly connected components (SCCs) present in the graph.
// A directed graph is said to be strongly connected if every vertex is reachable from every other vertex. The strongly connected components of a graph are the subgraphs which are themselves strongly connected.


// Steps:-
// 1.Sort all nodes on the basis of their finishing time(Topological sort)
// 2.Transpose of graph
// 3.DFS on all nodes according to ordering generated by toplogical sort

void DFS(int node,vector<bool> &visited,unordered_map<int,list<int>> &adj,stack<int> &st){
    visited[node]=true;
    for(auto neighbour:adj[node]){
        if(!visited[neighbour]){
            DFS(neighbour,visited,adj,st);
        }
    }
    st.push(node);
}

void newDFS(int node,unordered_map<int,list<int>> &adj,vector<bool> &visited){
    visited[node]=true;
    for(auto neighbour:adj[node]){
        if(!visited[node]){
            newDFS(neighbour,adj,visited);
        }
    }
}
int stronglyConnectedComponents(int v,vector<vector<int>> graph){

    unordered_map<int,list<int>> adj;
    for(auto i:graph){
        adj[i[0]].push_back(i[1]);
    }
    // Get Topological sort 
    stack<int> st;
    vector<bool> visited(v);
    for(int i=0;i<v;i++){
        if(!visited[i]){
            DFS(0,visited,adj,st);
        }
    }

    // Transpose of graph
    // unordered_map<int,list<int>> transposeGraph;
    // for(auto i:graph){
    //     transposeGraph[i[1]].push_back(i[0]);
    // }

    unordered_map<int, list<int> > transpose;
    for(int i=0; i<v; i++) {
        // to use it for next DFS
        visited[i]=false;
        for(auto nbr: adj[i]) {
            transpose[nbr].push_back(i);
        }
    }

    // DFS call according to toplogical sort
    int cnt;
    while (!st.empty())
    {
        int top=st.top();
        st.pop();
        if(!visited[top]){
            cnt++;
            newDFS(top,transpose,visited);
        }
    }
    return cnt;
}



int main(){

    return 0;
}